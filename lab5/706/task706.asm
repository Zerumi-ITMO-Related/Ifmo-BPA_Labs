ORG 0x11A
STR: WORD 0x055B
START: CLA

S1: IN 0x05
AND #0x40
BEQ S1
IN 0x04
ST (STR)
CMP #0x00
BEQ PHLT

S2: IN 0x05
AND #0x40
BEQ S2
LD (STR)
SWAB
IN 0x04
ST (STR)+
SXTB
CMP 0x00
BEQ PHLT
JUMP S1

PHLT: HLT
ORG 0x55B
WORD ?

ORG 0x11A ; Программа начинается с адреса 11A
STR: WORD 0x055B ; Размещаемая строка находится по адресу 55B
POINTER: WORD ? ; ?? Указатель на текущие 2 символа
START: CLA
LD STR
ST POINTER ; Инициализируем указатель
S1: IN 0x05 ; Ожидание вывода первого символа
AND #0x40 ; Бит 6 SR == 0 («Готов» нажата?)
BEQ S1 ; Нет – «Спин-луп»
IN 0x04 ; Иначе читаем символ c ВУ-2...
ST (POINTER) ; …И сохраняем в память
CMP #0x00 ; Перед нами стоп-символ?
BEQ PHLT ; Да – на выход!
S2: IN 0x05 ; Ожидание вывода второго символа
AND #0x40 ; Бит 6 SR == 0 (“Готов” нажата?)
BEQ S2 ; Нет – «Спин-луп»
LD (POINTER) ; Иначе загрузим предыдущий символ строки
SWAB ; Выберем второй символ в младшем байте…
IN 0x04 ; …И введем второй символ с ВУ-2
SWAB ; Обменяем порядок байтов для соблюдения требований
ST (POINTER)+ ; Сохраним окончательный элемент строки
SWAB ; Вернемся ко второму символу
SXTB ; Расширим знак, чтобы первый символ нам не мешал
CMP #0x00 ; Перед нами стоп-символ?
BEQ PHLT ; Да – на выход!
JUMP S1 ; И так далее...
PHLT: HLT ; Тот самый выход!
ORG 0x5AF ; Строка начинается здесь
WORD ?

